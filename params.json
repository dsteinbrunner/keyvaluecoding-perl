{"name":"Keyvaluecoding-perl","body":"## Object::KeyValueCoding\r\n\r\nOne of the greatest things about developing using the NeXT/Apple toolchain\r\nis the consistent use of something called key-value coding.  It's the kind\r\nof thing that, once you buy into its philosophy, will suddenly make a whole\r\nslew of things easier for you in ways that you never thought of before.\r\nEvery time I move to a new platform, be it Python or Javascript or Perl,\r\nI always find myself frustrated by its absence, and find myself jumping\r\nthrough all kinds of stupid hoops just to do things that would be dead-simple\r\nif key-value coding were available to me.\r\n\r\nSo here is a Perl implementation of KVC that you can\r\nglom onto your objects, or even glom onto everything in your system,\r\nand KVC will be available in all its glory (well, some of its glory...\r\nsee below).\r\n\r\n(Note: there's also an almost-identical Javascript implementation of\r\nkey-value coding [here](http://quile.github.com/keyvaluecoding-js/).)\r\n\r\n\r\n### Installing\r\n\r\nThe recommended way to install this module is to use cpanm:\r\n\r\n```\r\ncpanm Object::KeyValueCoding\r\n```\r\n\r\nalthough you can also download it from [github](https://github.com/quile/keyvaluecoding-js) if you want the bleeding edge.\r\n\r\n\r\n### Usage\r\n\r\nIf you just do this in a class:\r\n\r\n    use Object::KeyValueCoding;\r\n\r\nit will add key-value coding methods to that class.  You don't\r\nneed to fiddle with your inheritance.  Subclasses of your class will\r\ninherit key-value coding methods.\r\n\r\nAt present, you can choose between two different implementations, \"simple\",\r\n(which only implements the very basics of key-value coding and key-path\r\ntraversal) or \"complex\" (which has much more powerful object graph traversal\r\ncapabilities).  You can do it like this:\r\n\r\n    use Object::KeyValueCoding implementation => \"simple\";\r\n\r\nIf you don't indicate an implementation, the default (\"complex\") will be\r\nused.\r\n\r\nYou can also add the optional \"additions\" (see below) like this:\r\n\r\n    use Object::KeyValueCoding additions => 1;\r\n\r\nwhich will add a number of helper methods into the resolution chain\r\nof the \"complex\" implementation.\r\n\r\nYou can also indicate a \"target\", which is the name of a class in\r\nwhich to install key-value coding.  You will generally not use this, but\r\nyou could conceivably use it to install key-value coding system-wide:\r\n\r\n    use Object::KeyValueCoding target => \"UNIVERSAL\";\r\n\r\nPurists' heads might explode at this idea, but it's not so strange - it's\r\nessentially how the NSKeyValueCoding \"category\" works in Objective-C.\r\n\r\n\r\n\r\n### Methods\r\n\r\nAll implementations of KVC must support these methods:\r\n\r\n    valueForKey( <key> )\r\n    valueForKeyPath( <keypath> )\r\n    setValueForKey( <value>, <key> )\r\n    setValueForKeyPath( <value>, <keypath> )\r\n\r\n\r\n\r\nAny KVC-aware objects will now respond to those methods.\r\n( Note: the difference between a key-path and a key is that a key-path can\r\nbe an arbitrarily long dot-path of keys ).\r\n\r\nHere is an example session that should show how it works:\r\n\r\n```\r\n    > re.pl\r\n    $ package Foo;\r\n      use base qw( Object::KeyValueCoding );\r\n      sub new { return bless $_[1] }\r\n    $ my $foo = Foo->new({ bar => \"This is foo.bar\",\r\n                           baz => { quux => \"This is foo.baz.quux\",\r\n                           bonk => [ 'This is foo.baz.bonk.@0', 'This is foo.baz.bonk.@1' ]\r\n                       }});\r\n    Foo=HASH(0x1020576c0);\r\n    $ $foo->valueForKey(\"bar\")\r\n    This is foo.bar\r\n    $ $foo->valueForKeyPath(\"baz.quux\")\r\n    This is foo.baz.quux\r\n    $ $foo->valueForKeyPath('baz.bonk.@1')\r\n    This is foo.baz.bonk.@1\r\n    $\r\n```\r\n\r\nIf a function is found rather than a property, it will\r\nbe called in the context of the object it belongs to:\r\n\r\n\r\n```\r\n    sub Foo::bing {\r\n        return [ 'This is foo.bing.@0', 'and this is foo.bing.@1' ];\r\n    }\r\n    $ $foo->valueForKey('bing.@1')\r\n    'and this is foo.bing.@1'\r\n    $\r\n```\r\n\r\n\r\nThe implementation allows nested key-paths, which are turned into arguments:\r\n\r\n\r\n```\r\n    $ sub Foo::bong { my ($self, $bung) = @_; return uc($bung) }\r\n    $ $foo->valueForKey(\"baz.quux\")\r\n    This is foo.baz.quux\r\n    $ $foo->valueForKey(\"bong(baz.quux)\")\r\n    THIS IS FOO.BAZ.QUUX\r\n    $ $foo->valueForKey(\"self.bong(self.baz.quux)\")\r\n    THIS IS FOO.BAZ.QUUX\r\n    $\r\n```\r\n\r\nSee how it traverses the object graph from one related object to another:\r\n\r\n```\r\n    $ package Goo; use base qw( Object::KeyValueCoding ); sub new { bless $_[1] }\r\n    $ my $goo = Goo->new({ something => $foo, name => \"I'm called Goo!\" });\r\n    Goo=HASH(0x1020763d8);\r\n    $ $goo->valueForKey(\"something.bong(name)\")\r\n    I'M CALLED GOO!\r\n    $ $goo->valueForKey(\"something.bong(self.name)\")\r\n    I'M CALLED GOO!\r\n    $ $goo->valueForKey(\"self.something.bong(self.name)\")\r\n    I'M CALLED GOO!\r\n    $\r\n```\r\n\r\nThe corresponding `set` methods, `setValueForKey` and `setValueForKeyPath`\r\nwill set the value on whatever object the key/keypath resolves to.\r\nIf any part of the key or keypath returns *null*, the call will\r\n(at present) fail silently.  __NOTE:__ This is not the same behaviour\r\nas Apple's NSKeyValueCoding; it's a bit more like the Clojure\r\n\"thread\" operator (->>).\r\n\r\n### Additions\r\n\r\nThe implementation has some optional \"additions\" that you can use.\r\nWhat are these \"additions\"?  They provide a number of \"special\" methods\r\nthat can be used in keypaths:\r\n\r\n```\r\n    eq(a, b)\r\n    not( a )\r\n    and( a, b )\r\n    or( a, b )\r\n    commaSeparatedList( a )\r\n    truncateStringToLength( a, l )\r\n    sorted( a )\r\n    reversed( a )\r\n    keys( a )\r\n    length( a )\r\n    int( a )\r\n```\r\n\r\nFor example:\r\n\r\n```\r\n    $ my $goo = Goo->new({ a => 1, b => 0, c => 0 });\r\n    Goo=HASH(0x1020633d0);\r\n    $ $goo->valueForKey(\"and(a, b)\")\r\n    0\r\n    $ $goo->valueForKey(\"or(a, b)\")\r\n    1\r\n    $ $goo->valueForKey(\"or(b, c)\")\r\n    0\r\n    $\r\n```\r\n\r\nNote that the arguments themselves can be arbitrarily long key-paths.\r\n\r\n\r\n### TODO\r\n\r\n* Better support for Moose - Since Moose is pretty much the defacto way now of doing OO\r\nin Perl, KVC should detect Moose and play nicer with it.  It means\r\nthat it could use the Class::MOP features to perform attribute\r\nmanipulation, so that will be fun.\r\n\r\n* Error handling - Right now you're on your own to test for errors and trap explosions.\r\n\r\n* Bulletproofing - There are lots of cases that could have slipped through the cracks, so it\r\nwill need some cleaning up and bulletproofing to harden it a bit.\r\n\r\n### History\r\n\r\nThis implementation originated as part of the Idealist Framework\r\n(https://github.com/quile/if-framework) over 10 years\r\nago.  It was loosely based on the NSKeyValueCoding protocol found\r\non NeXTStep/OpenStep (at that time) and now Cocoa/iOS.  This is the\r\nreason why the code is a bit hairy - its very old (predating pretty much\r\nevery advance in Perl...).  But that works in its favour, because it\r\nmeans it will work well with most Perl objects and isn't bound to\r\nan OO implementation like Moose.\r\n\r\n\r\n### See Also\r\n\r\n[Near-identical Javascript Implementation](http://quile.github.com/keyvaluecoding-js/)","tagline":"Perl implementation of NSKeyValueCoding category","google":"UA-30714478-2","note":"Don't delete this file! It's used internally to help with page regeneration."}